//! Example of implementing a custom entropy source

use entropy_weaver::entropy::EntropySource;
use entropy_weaver::quality::QualityMetrics;
use entropy_weaver::crypto::StreamCipher;

/// Simple custom RNG (DO NOT USE IN PRODUCTION!)
/// This is just an example of implementing the EntropySource trait.
struct SimpleRNG {
    state: u64,
}

impl SimpleRNG {
    fn new(seed: u64) -> Self {
        Self { state: seed }
    }
}

impl EntropySource for SimpleRNG {
    fn fill_bytes(&mut self, dest: &mut [u8]) {
        for byte in dest.iter_mut() {
            // Simple Linear Congruential Generator
            self.state = self.state.wrapping_mul(1103515245).wrapping_add(12345);
            *byte = (self.state >> 24) as u8;
        }
    }
    
    fn name(&self) -> &str {
        "Simple LCG RNG (example only)"
    }
}

fn main() {
    println!("=== Custom Entropy Source Example ===\n");
    
    // Create custom source
    let mut rng = SimpleRNG::new(42);
    println!("Using: {}", rng.name());
    
    // Generate some bytes
    let mut buffer = [0u8; 16];
    rng.fill_bytes(&mut buffer);
    println!("\nGenerated bytes: {}", hex::encode(buffer));
    
    // Use with cipher
    println!("\n--- Using with StreamCipher ---");
    let mut cipher = StreamCipher::new(SimpleRNG::new(42));
    let plaintext = b"Custom source test";
    let ciphertext = cipher.process(plaintext);
    println!("Encrypted: {}", hex::encode(&ciphertext));
    
    // Analyze quality
    println!("\n--- Quality Analysis ---");
    let mut test_rng = SimpleRNG::new(42);
    let metrics = QualityMetrics::analyze(&mut test_rng, 100_000);
    
    println!("Shannon Entropy: {:.4} bits/byte", metrics.shannon_entropy);
    println!("Min-Entropy:     {:.4} bits/byte", metrics.min_entropy);
    println!("Overall Score:   {:.1}/100", metrics.overall_score());
    
    println!("\nNote: This simple RNG has lower quality than system RNG.");
    println!("For production use, implement a cryptographically secure RNG.");
}
